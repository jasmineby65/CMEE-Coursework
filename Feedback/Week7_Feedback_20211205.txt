Starting code feedback for Zhengxin, Week7

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 35.23 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: week5, week4, week1, week2, week7, .git, MiniProject, week8, week3, Feedback

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*.aux
*.bbl
*.blg
*.log
*.pdf
*.png
__pycache__/
*.py[cod]
#This is automatically made when a program is imported in python 
.RData
.Rhistory
results/
!results/.gitkeep
.ipynb_checkpoints/
plots/
!plots/.gitkeep
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
### Jasmine Yang's CMEECoursework Repository  
- Detailed explanation of folder contents can be found in each folder.

**********************************************************************

======================================================================
Looking for the weekly directories...

Found 7 weekly directories: week1, week2, week3, week4, week5, week7, week8

The Week7 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK7...

Found the following directories: code, data, sandbox, results

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# DrawFW.py  
Creates and plot a simple food web network with node sized corresponding to each species's biomass.  
Language: python3  

### Usage
```python
# Required packages: networkx, sumpy, matplotlib.pylab
%run DrawFW.py
```

&nbsp;

# LV1.py
Integrating the Lotka-Volterra model to calcuate the population density at different time points and produce two pdf plots from example data.  
Language: python3

### Usage
```python
# Required packages: numpy, matplotlib.pylab, scipy.integrate 
%run LV1.py

# Functions:
import LV1
dCR_dt(pops, t=0) # Function that contains the Lotka-Volterra model
``` 

&nbsp;

# oaks_debugme.py
Runs through species name in a csv file and saves the oak species (Quercus) in a new csv (JustOaksData.csv).   
Language: python3

### Usage
```python
# Required packages: csv, sys
%run oaks_debugme.py

# Functions:
import oaks_debugme.py
is_an_oak(name) # Returns True if name is starts with 'Quercus'
```

&nbsp;

# profileme.py
Example functions to be tested for code running time.  
Language: python3 

### Usage
```python
import profileme

# Function that produce a list of squared number series
my_squares(iters)

# Function that joins "string" iters times, seperated by ","
my_join(iters, string)

# Runs function my_squares and my_join 
run_my_funcs(x,y)
```

&nbsp;

# profileme2.py
Improved example functions to be tested for code running time.  
Language: python3

### Usage 
```python
#Required packages: numpy
import profileme2

# Function that produce a list of squared number series 
my_squares(iters)

# Function that joins "string" iters times, seperated by ","
my_join(iters, string)

# Runs function my_squares and my_join
run_my_funcs(x,y)
```

&nbsp;

# regexs.py
Examples of using regex for seaching in Python.  
Language: python3

### Usage
```python
# Required packages: re, urllib3
%run regex.py
```

&nbsp;

# TestR.py
Running R from python using subprocess.  
Language: python3 & R

### Usage
```python
# Required packages: subprocess
%run TestR.py
```

&nbsp;

# TestR.R
Print "Hello, this is R!".  
Language: R

### Usage
```R
source("TestR.R")
```

&nbsp;

# timeitme.py
Testing timeit for profiling.  
Language: python3

### Usage
```python
# Required packages: timeit, profileme.py, profileme2.py
%run timeitme.py

# Profiling functions from profileme.py and profileme2.py
%timeit my_squares_loops(iters)
%timeit my_squares_lc(iters)
%timeit (my_join_join(iters, mystring))
%timeit (my_join(iters, mystring))
```
**********************************************************************

Results directory is empty - good! 

Found 10 code files: TestR.py, profileme.py, regexs.py, oaks_debugme.py, MyFirstJupyterNb.ipynb, profileme2.py, TestR.R, LV1.py, DrawFW.py, timeitme.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file TestR.py...

File contents are:

**********************************************************************
## R can be run from python using subprocess
""" Running R from python using subprocess """ 

import subprocess

subprocess.Popen("Rscript --verbose TestR.R > ../results/TestR.Rout 2> ../results/TestR_errFile.Rout", shell=True).wait()
# --verbose will show what R is actually doing
# ">" is used to assign the output to assign the output to files
# "2>" assigns the second output, which is content of --verbose in this case

subprocess.Popen("Rscript --verbose NonExistScript.R > ../results/outputFile.Rout 2> ../results/errorFile.Rout", shell=True).wait()
# Since the R script don't exist, the stored output it the error message 
**********************************************************************

Testing TestR.py...

TestR.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.08981s

======================================================================
Inspecting script file profileme.py...

File contents are:

**********************************************************************
## Profiling ##
# Run the script in ipython with "run -p "
# Or "python3 -m cProfile xxx.py" from bash
# Allows identificaton of functions that are slowing the code down

""" Example functions to be tested for code running time """ 

def my_squares(iters):
    """ function that produce a list of squared number series """
    out = []
    for i in range(iters):
        out.append(i ** 2)
    return out

def my_join(iters, string):
    """ function that joins "string" iters times, seperated by "," """
    out = ''
    for i in range(iters):
        out += string.join(", ")
    return out

def run_my_funcs(x,y):
    """ Runs function my_squares and my_join """
    print(x,y)
    my_squares(x)
    my_join(x,y)
    return 0 

run_my_funcs(10000000, "My string")


**********************************************************************

Testing profileme.py...

profileme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
10000000 My string

**********************************************************************

Code ran without errors

Time consumed = 5.21267s

======================================================================
Inspecting script file regexs.py...

File contents are:

**********************************************************************
#### Regex in Python ####
""" Examples of using regex for seaching in Python """
import re 

my_string= "a given string"
match = re.search(r'\s', my_string) # searches for any whitespace character in my_string
print(match) # This only shows whether an match is made or not]
match # Same as above
match.group() # Actually sees the match

match = re.search(r'\d', my_string) # searches for any numeric integer
print(match)

MyStr = "an example"
# searches for whitespace alphanumeric characters preceeded or not preceeded by alphanumeric  
match = re.search(r'\w*\s', MyStr) 
# Checking if a match was made or not using 'if'
if match:
    print("Found a match:", match.group())
else:
    print("No match ):")

match = re.search(r'2', "it takes 2 to tango")
match.group()

match = re.search(r'\d', "it takes 2 to tango")
match.group()

# Searches for numeric and anything that follows it for any length
match = re.search(r'\d.*', "it takes 2 to tango")
match.group()

# Searches for any alphanumeric character of length 1 or 3 surrounded by whitespace
match = re.search(r'\s\w{1,3}\s', "once upon a time")
match.group()

# Searches for alphanueric character of any length at the end of a string preceded by a whitespace
match = re.search(r'\s\w*$', "once upon a time")
match.group()

# .group() can be put straight after the .search
# Searches for any length of anything before whitespace followed by a numeric
# followed by any length of anything before another numeric 
re.search(r'\w*\s\d.*\d', "takes 2 grams of H2O").group()

# Searches for anything of any length following alphanumeric before a space
re.search(r'^\w*.*\s', "once upon a time").group()
# Anything preceded by *, + and {} is repeated as many times as possible 
# until hitting the next meta/regularcharacter
# In this case, all three words before "time" not followed by space are searched 

# Only searches until the first result:
# ? should be placed right after *, +, () to stop their action 
re.search(r'^\w*.*?\s', "once upon a time").group()

re.search(r'<.+>', 'This is a <EM>first</EM> test').group()
re.search(r'<.+?>', 'This is a <EM>first</EM> test').group()

# \ before . finds the literal "."
re.search(r'\d*\.?\d*', "1432.75+60.22i").group()

# Find any A, G, T, C
re.search(r'[AGTC]+', "the sequence ATTCGT").group()

# Find any alphanumeric preceded by a space and capital letter and any alphanumeric followed by that with a space 
re.search(r'\s+[A-Z]\w+\s*\w+', "The bird-shit frog's name is Theloderma asper.").group()

# Finding profile of people (name, email, description)
MyStr = 'Samraat Pawar, s.pawar@imperial.ac.uk, Systems biology and ecological theory'
match = re.search(r"[\w\s]+,\s[\w\.@]+,\s[\w\s]+",MyStr)
match.group() 


# Different format of email
MyStr = 'Samraat Pawar, s-pawar@imperial.ac.uk, Systems biology and ecological theory'
match = re.search(r"[\w\s]+,\s[\w\.@]+,\s[\w\s]+",MyStr)
match.group() # When there is no match, group() will give error
match = re.search(r"[\w\s]+,\s[\w\.-]+@[\w\.-]+,\s[\w\s]+",MyStr)
match.group()


## Grouping regex patterns ##
MyStr = 'Samraat Pawar, s.pawar@imperial.ac.uk, Systems biology and ecological theory'
match = re.search(r"[\w\s]+,\s[\w\.-]+@[\w\.-]+,\s[\w\s]+",MyStr)
match.group()
match.group(0) # without grouping, all the outputs are in a single line

# With grouping by ():
match = re.search(r"([\w\s]+),\s([\w\.-]+@[\w\.-]+),\s([\w\s&]+)",MyStr)
if match:
    print(match.group(0)) # All output
    print(match.group(1)) # First group 
    print(match.group(2)) # Second group
    print(match.group(3)) # Third group 


## Different Regex commands ##
MyStr = "Samraat Pawar, s.pawar@imperial.ac.uk, Systems biology and ecological theory; Another academic, a-academic@imperial.ac.uk, Some other stuff thats equally boring; Yet another academic, y.a_academic@imperial.ac.uk, Some other stuff thats even more boring"

# findall() will return a list of all matches
emails = re.findall(r'[\w\.-]+@[\w\.-]+', MyStr)
for email in emails:
    print(email)
# Whereas, search() will only give the first match 
re.search(r'[\w\.-]+@[\w\.-]+', MyStr).group()

# findall() can also search through all the lines in a file
f = open("../data/TestOaksData.csv","r")
found_oaks = re.findall(r"Q[\w\s].*\s", f.read()) 
# .read() returns the whole text in a file as a single string
found_oaks

# findall() can also be combined with () grouping 
MyStr = "Samraat Pawar, s.pawar@imperial.ac.uk, Systems biology and ecological theory; Another academic, a.academic@imperial.ac.uk, Some other stuff thats equally boring; Yet another academic, y.a.academic@imperial.ac.uk, Some other stuff thats even more boring"
found_matches = re.findall(r"([\w\s]+),\s([\w\.-]+@[\w\.-]+)", MyStr)
found_matches # Returns a list of tuple instead of list of strings
for item in found_matches:
    print(item)

## Extracting text from webpages ##

import urllib3 # for extracting website text 

conn = urllib3.PoolManager() # opens a connection to start extracting data from somewhere 
# request() sends a request to the website and "GET" specify the data to be in the form of HTTPResponse object 
r = conn.request("GET", "https://www.imperial.ac.uk/silwood-park/academic-staff/")
webpage_html = r.data # read the data in the HTTPResponce 
type(webpage_html) # This data is in the form of byte not strings so needs decoding
My_Data = webpage_html.decode()
print(My_Data)

pattern = r"(Dr|Professor)\s+(\w{3,}\s+\w+)" # "|" means "or" and {3,} specifies the length to be at least 3 
# compile() compiles a regular expression for repeated use  
regex = re.compile(pattern) 
# finditer() is basically the same as findall() but returns a iterator with the match object so it can be iterated e.g. looped
result = []
for match in regex.findall(My_Data): 
    if match not in result:
        result.append(match)

result


## Replacing text ##
New_Data = re.sub(r'\t'," ", My_Data) # replace all tabs with a space
print(New_Data)

**********************************************************************

Testing regexs.py...

regexs.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
<_sre.SRE_Match object; span=(1, 2), match=' '>
None
Found a match: an 

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "regexs.py", line 77, in <module>
    match.group() # When there is no match, group() will give error
AttributeError: 'NoneType' object has no attribute 'group'

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:

**********************************************************************
""" Runs through species name in a csv file and saves the oak species (Quercus) in a new csv (JustOaksData.csv) """

import csv
import sys

#Define function
def is_an_oak(name):
    """ Returns True if name is starts with 'Quercus' 
    
    >>> is_an_oak("Quercus")
    True
    
    >>> is_an_oak("Genus")
    False

    >>> is_an_oak("Fraxinus")
    False

    >>> is_an_oak("Pinus")
    False

    >>> is_an_oak("Quercuss")
    False
    """
    return name == 'Quercus'

def main(argv): 
    """ Produce a csv file containing the name of oak species found in the input csv file """
    f = open('../data/TestOaksData.csv','r')
    g = open('../results/JustOaksData.csv','w')
    taxa = csv.reader(f)
    next(taxa, None) # Skips a row i.e. ignores header
    csvwrite = csv.writer(g)
    oaks = set()
    #import ipdb; ipdb.set_trace()
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])    

    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)
**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.02523s

======================================================================
Inspecting script file MyFirstJupyterNb.ipynb...

File contents are:

**********************************************************************
{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "e63dfdff",
   "metadata": {},
   "source": [
    "The logistic growth equation:   \n",
    "$$\\frac{dN}{dt} = rN \\left(1-\\frac{N}{K}\\right)$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "8f5c36ba",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "this is python!\n"
     ]
    }
   ],
   "source": [
    "a = \"this is python!\"; print(a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "96c7943f",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as p\n",
    "import numpy as np\n",
    "\n",
    "x = np.arange(0,5,0.1); y=np.sin(x)\n",
    "p.plot(x,y); p.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

**********************************************************************

Testing MyFirstJupyterNb.ipynb...

======================================================================
Inspecting script file profileme2.py...

File contents are:

**********************************************************************
""" Improved example functions to be tested for code running time """ 

## Improved speed ##
import numpy as np

# Comprehensions saves time compared to for loops
# Preallocating numpy arrays saves more time than allocating list
def my_squares(iters):
    """ function that produce a list of squared number series """
    out = np.array(i ** 2 for i in range(iters))
    return out

# join() is slower than "+" to concatinate variables 
def my_join(iters, string):
    """ function that joins "string" iters times, seperated by "," """
    out = ''
    for i in range(iters):
        out += ", " + string
    return out

def run_my_funcs(x,y):
    """ Runs function my_squares and my_join """
    print(x,y)
    my_squares(x)
    my_join(x,y)
    return 0 

run_my_funcs(10000000, "My string")

# Arguments for profiling
# -s sorts the result by specified section e.g. "run -p -s cuttime xxx.py"
# -l filters the results by function name and reduce the number of lines displayed
# -T saves the report in a text file
**********************************************************************

Testing profileme2.py...

profileme2.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
10000000 My string

**********************************************************************

Code ran without errors

Time consumed = 1.06970s

======================================================================
Inspecting script file TestR.R...

File contents are:

**********************************************************************
print("Hello, this is R!")
**********************************************************************

Testing TestR.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Hello, this is R!"

**********************************************************************

Code ran without errors

Time consumed = 0.05341s

======================================================================
Inspecting script file LV1.py...

File contents are:

**********************************************************************
""" Integrating the Lotka-Volterra model to calcuate the population density at different time points """

import numpy as np
import matplotlib.pylab as p
import scipy.integrate as integrate

## Lotka-Volterra model ##

# dR/dt = rR - aCR
# dC/dt = eaCR - zC

# R and C are the predator and prey popualtion abundances (number/area)
# r is the intrinsic growth rate of prey
# a is the per-capita "search rate" for the prey multiplied by its attack success probability
# i.e. the encounter and consumption rate of the consumer on the resource
# z is mortality rate of predator
# e is the predator's efficienty (fraction) in converting prey to biomass

# Need to integrate the equations by t to be able to add time as a variable 
# Defining a function that returns the growth rate of predaor and prey at any given time

def dCR_dt(pops, t=0):
    """ function that contains the Lotka-Volterra model """ 
    R = pops[0]
    C = pops[1]
    dRdt = r*R - a*R*C
    dCdt = e*a*R*C - z*C 

    return np.array([dRdt, dCdt])

type(dCR_dt)

# Defining parameters
r = 1.
a = 0.1
z = 1.5
e = 0.75

# Defining the time vector, integrating from time point 0 to 15, using 1000 sub-divisions of time
# linspace() returns evenly spaced numbers over a specified interval 
t = np.linspace(0, 15, 1000) # takes 1000 numbers between 0 and 15 at even interval

# Defining the initial populations 
R0 = 10
C0 = 5
RC0 = np.array([R0, C0])

# Integrating the equations in dCR_dt
# odeint() integrate a system of ordinary differential equations
# first parameter: a function that contains the equations
# 2nd parameter: an array that contains the initial condition of y
# 3rd parameter: sequence of time points for which to solve for y
# full_output=T produce a dictionary contianing additional info
pops, infodict = integrate.odeint(dCR_dt, RC0, t, full_output = True)
pops
type(infodict)
infodict.keys()

# Plotting the results 1
f1 = p.figure() # assigning a object for the figure

# plot a line with t on x-axis, first column of pops on y-axis
p.plot(t,pops[:,0], 'g-', label="Resource density") # 'g-' gives green line
p.plot(t, pops[:,1], "b-", label="Consumer density")
p.grid() # adds grid
p.legend(loc="best") # add legend
p.xlabel("Time")
p.ylabel("Popualtion density")
p.title("Consumer-Resource popualtion dynamics")
#p.show()

# Saving the figure as pdf
f1.savefig("../results/LV_model.pdf")


# Plotting the result 2
f2 = p.figure()
p.plot(pops[:,0], pops[:,1], "r-")
p.grid()
p.xlabel("Resource density")
p.ylabel("Consumer density")
p.title("Consumer-Resource population dynamics")
#p.show()
f2.savefig("../results/LV_model2.pdf")
**********************************************************************

Testing LV1.py...

LV1.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.78907s

======================================================================
Inspecting script file DrawFW.py...

File contents are:

**********************************************************************
"""Creating a simple food web network"""

import networkx as nx # used for building network
import numpy as np
import matplotlib.pylab as p

def GenRdmAdjList(N=2, C=0.5):
    """ 
    Generating a symthetic food web consisting of a random adjacency list (a matrix with consumer in 1st column and 
    resource in the 2nd column and a seperate matrix of each species' properties e.g. biomass) of a N-species food web
    with connectance probability of C (the probability of having a link between any pair of species in the food web)
    """
    Ids = range(N)
    ALst = []
    for i in Ids:
        if np.random.uniform(0,1,1) < C: # A random no. bewteen 0 and 1
            Lnk = np.random.choice(Ids,2).tolist() 
            # generate a random sample from an given array (2 from Ids here) and assign it as a list
            if Lnk[0] != Lnk[1]: # avoiding assigning the same species for both position
                ALst.append(Lnk)
    return ALst


MaxN = 30
C = 0.75

# Generating adjacency list: 
# Pairs of consumer id and resource id that have interaction 
AdjL = np.array(GenRdmAdjList(MaxN,C))
AdjL

# Generating species data (nodes)
Sps = np.unique(AdjL) # Obtaining a list of species from the adjacency list
Sps

# Body size for the species
SizRan = ([-10,10]) # In log10 scale
Sizs = np.random.uniform(SizRan[0], SizRan[1], MaxN)
Sizs

p.hist(Sizs)
#p.show()

p.hist(10 ** Sizs) # In raw scale
#p.show()

p.close("all") # Closing all the open plot objects

# Plotting the network #
# Making a circular configuration for each species 
pos = nx.circular_layout(Sps)
pos

G = nx.Graph() # Making a networkx graph object
G.add_nodes_from(Sps)
G.add_edges_from(tuple(AdjL)) # Only takes a tuple object

# Generate node sizes proportional to the log body size
NodSizes = 400 * (Sizs - min(Sizs)/(max(Sizs) - min(Sizs)))
NodSizes 

# Plotting the nexwork 
fig = p.figure(figsize=(15,10))
nx.draw_networkx(G, pos = pos, node_size = NodSizes)
p.show()
fig.savefig("../results/FoodWed.pdf")
**********************************************************************

Testing DrawFW.py...

DrawFW.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):
can't invoke "event" command: application has been destroyed
    while executing
"event generate $w <<ThemeChanged>>"
    (procedure "ttk::ThemeChanged" line 6)
    invoked from within
"ttk::ThemeChanged"

======================================================================
Inspecting script file timeitme.py...

File contents are:

**********************************************************************
## timeit ##
# Loops at the time of specific function within the program instead of whole program
# Run "%timeit function(x)" (need to import timeit) in the terminal

""" Testing timeit for profiling """ 

#################################################
# loops vs list comprehensions: which is faster?
#################################################

iters = 10000000

import timeit

from profileme import my_squares as my_squares_loop
from profileme2 import my_squares as my_square_lc


#####################################################
# loops vs join method for strings: which is faster?
#####################################################
mystring = "my string"

from profileme import my_join as my_join_join
from profileme2 import my_join as my_join



**********************************************************************

Testing timeitme.py...

timeitme.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
10000000 My string
10000000 My string

**********************************************************************

Code ran without errors

Time consumed = 6.23986s

======================================================================
======================================================================
Finished running scripts

Ran into 2 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 100

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!